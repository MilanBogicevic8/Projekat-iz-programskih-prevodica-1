package rs.ac.bg.etf.pp1;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Stack;

import rs.ac.bg.etf.pp1.CounterVisitor.VarCounter;
import rs.ac.bg.etf.pp1.ast.*;
import rs.etf.pp1.mj.runtime.Code;
import rs.etf.pp1.symboltable.Tab;
import rs.etf.pp1.symboltable.concepts.Obj;
import rs.etf.pp1.symboltable.concepts.Scope;
import rs.etf.pp1.symboltable.concepts.Struct;

public class CodeGenerator extends VisitorAdaptor {

	private int mainPc;
	public int getMainPc() {
		return mainPc;
	}
	
	Scope currentScope = Tab.currentScope;
	/**
	 * U hes tabeli prosledjenog opsega trazi Obj cvor sa imenom name, pocevsi od
	 * prosledjenog opsega, pa redom kroz opsege na nizim nivoima. Povratna
	 * vrednost: - pronadjeni Obj cvor, ako je pretrazivanje bilo uspesno. -
	 * Tab.noObj objekat, ako je pretrazivanje bilo neuspesno.
	 */
	public static Obj find(String name, Scope scope) {
		Obj resultObj = null;
		for (Scope s = scope; s != null; s = s.getOuter()) {
			if (s.getLocals() != null) {
				resultObj = s.getLocals().searchKey(name);
				if (resultObj != null)
					break;
			}
		}
		return (resultObj != null) ? resultObj : Tab.noObj;
	}
	
	/**
	 * Matched ::= (DesStm) DesignatorStatement SEMICOLON
			|
			(IfElseMatched) IF IfBegin Condition IfEpsilon RPAREN Matched ELSE Matched
			|
			(StmtBreak) BREAK SEMICOLON
			|
			(StmtContinue) CONTINUE SEMICOLON
			|
			(StmtReturn) RETURN AdditionalExpr SEMICOLON
			|
			(StmtRead) READ LPAREN Designator RPAREN SEMICOLON
			|
			(StmtPrint) PRINT LPAREN Expr AdditionalPrintNum RPAREN SEMICOLON
			|
			(StmtFor) ForBegin Matched ForEnd
			|
			(StmtFor2) ForBegin Unmatched ForEnd
			|
			(StmtStmt) LBRACE StatementList RBRACE
			;
			
			AdditionalPrintNum ::= (AddPrintN) COMMA NUMCONST
						|
						(NoAddPrintN) \/*epsilon*\/
						;
	 */
	/*********************************PRINT***************************/
	public void visit(StmtPrint print) {//podrazumeva se da je vrednost vec na steku
		if(print.getExpr().struct==Tab.intType || print.getExpr().struct==SemanticAnalyzer.booleanType) {
			Code.put(Code.print);
		}else if(print.getExpr().struct==Tab.charType) {
			Code.put(Code.bprint);
		}else {//boolenantype
			//err
		}
		
	}
	
	public void visit(AddPrintN apn) {
		StmtPrint pstm=(StmtPrint) apn.getParent();
		
		Integer width=apn.getVal();
		Code.loadConst(width);	
	}
	
	public void visit(NoAddPrintN napn) {
		StmtPrint stmt=(StmtPrint)napn.getParent();
		Expr expr=stmt.getExpr();
		if(expr.struct==Tab.intType) Code.loadConst(5);
		else if(expr.struct==SemanticAnalyzer.booleanType) Code.loadConst(5);
		else Code.loadConst(1);
	}
	
	/******************************READ************************************/
	
	public void visit(StmtRead read) {
		Designator des=read.getDesignator();
		if(des.obj.getType()==Tab.charType) Code.put(Code.bread);
		else Code.put(Code.read);
		
		Code.store(des.obj);//storujemo procitanu vrednost u des.obj
	}
	
	/****************************Global functions****************************/
	/**
	 * MethodDecl ::= (MethodDecl) TypeOrVoid LPAREN AdditionalFormPars RPAREN OptionalMethVarDeclL LBRACE StatementList RBRACE;
	 * TypeOrVoid ::= (TypeOpt) Type IDENT:name
				|
				(VoidOpt) VOID IDENT:name
				;
	   AdditionalExpr ::= (AddExpr) Expr
					|
				   (NoAddExpr) \/*epsilon*\/
				    ;
	   
	 */
	private Obj currMethod=null;
	private Boolean returnStmtFound=false;
	public void initVFP() {
		int varCnt=SemanticAnalyzer.nVars;
		for(Obj obj:this.hashOfClasses.keySet()) {
			hashOfClasses.put(obj, varCnt);
			for(Obj meth:obj.getType().getMembers()) {
				if(meth.getKind()==Obj.Meth) {
					String name=meth.getName();
					//ubacivanje slovo po slovo metode
					for(int i=0;i<name.length();i++) {
						char c=name.charAt(i);
						Code.loadConst(c);
						Code.put(Code.putstatic);
						Code.put2(varCnt);
						varCnt++;
					}
				}
				//kraj metode
				Code.loadConst(-1);
				Code.put(Code.putstatic);
				Code.put2(varCnt);
				varCnt++;
				Code.loadConst(meth.getAdr());
				Code.put(Code.putstatic);
				Code.put2(varCnt);
				varCnt++;
			}
		}
		//kraj tabele simbola
		Code.loadConst(-2);
		Code.put(Code.putstatic);
		Code.put2(varCnt);
		varCnt++;	
		SemanticAnalyzer.nVars=varCnt;
	}
	
	public void visit(TypeOpt to) {
		to.obj.setAdr(Code.pc);
		int level=to.obj.getLevel();
		int argNum=to.obj.getLocalSymbols().size();
		Code.put(Code.enter);
		Code.put(level);
		Code.put(argNum);
		this.currMethod=to.obj;
	}
	
	public void visit(VoidOpt vo) {
		vo.obj.setAdr(Code.pc);
		String name=vo.obj.getName();
		if("main".equals(name)) {
			//ovde treba inicijalizovati tableu virtuelnih funkcija
			this.mainPc=Code.pc;//prva instrukcija koja se izvrsava
			initVFP();
			
		}
		int level=vo.obj.getLevel();
		int argNum=vo.obj.getLocalSymbols().size();
		Code.put(Code.enter);
		Code.put(level);
		Code.put(argNum);
		this.currMethod=vo.obj;
		
	}
	//return stmt
	public void visit(AddExpr aexpr) {
		Code.put(Code.exit);
		Code.put(Code.return_);
		returnStmtFound=true;
	}
	
    public void visit(MethodDecl md) {
		if(!returnStmtFound) {
			Struct mdStruct=md.obj.getType();
			if(mdStruct==Tab.noType) {
				//ako je povratna vrednost void i nema return-a OK
				Code.put(Code.exit);
				Code.put(Code.return_);
			}else {
				//ako je povratna vrednost!=null, a ne vraca se nista
				//runtime error
				Code.put(Code.trap);
				Code.put(1);
			}
		}
		returnStmtFound=false;currMethod=null; 
	}
    //MethodDeclClass ::= (MethodDeclClass) TypeOrVoid LPAREN AdditionalFormPars RPAREN OptionalMethVarDeclL LBRACE StatementList RBRACE;
    List<Obj> listaMetodaUKlasama=new ArrayList<>();
    public void visit(MethodDeclClass mdc) {
    	if(!returnStmtFound) {
			Struct mdStruct=mdc.obj.getType();
			if(mdStruct==Tab.noType) {
				//ako je povratna vrednost void i nema return-a OK
				Code.put(Code.exit);
				Code.put(Code.return_);
			}else {
				//ako je povratna vrednost!=null, a ne vraca se nista
				//runtime error
				listaMetodaUKlasama.add(currMethod);
				Code.put(Code.trap);
				Code.put(1);
			}
		}
    	
		returnStmtFound=false;currMethod=null; 
    }
    /***********************EXPR*********************************/
    /**
     * 
     * Expr ::= (Expr) AdditionalMinus Term OptionalAddopTerm;

		AdditionalMinus ::= (AdditMinus) MINUS
							|
							(NoAdditMinus) \/*epsilon*\/
							;
		OptionalAddopTerm ::= (OptAddTerm) OptionalAddopTerm Addop Term
							  |
							  (NoOptAddTerm) \/*epsilon*\/
							  ;
		Addop ::= (AddOpPlus) PLUS
		  |
		  (AddOpMinus) MINUS
		  ;
     */
    
    public void visit(AdditMinus am) {
    	Code.put(Code.neg);
    }
    
    public void visit(OptAddTerm oat) {
    	if(oat.getAddop() instanceof AddOpPlus) Code.put(Code.add);
    	else if(oat.getAddop() instanceof AddOpMinus) Code.put(Code.sub);
    }
	
    /************************TERM***************************/
    /**
     * Term ::= (Term) Factor OptionalTermMulop;

		OptionalTermMulop ::= (OptTermMul) OptionalTermMulop Mulop Factor
							  |
							  (NoOptTermMul) \/*epsilon*\/
							  ;
		Mulop ::= (MulopMul) MUL
		   |
		   (MulopDiv) DIV
		   |
		   (MulopPercent) PERCENT
		   ;
		   
     */
    
    public void visit(OptTermMul otm) {
    	if(otm.getMulop() instanceof MulopMul) Code.put(Code.mul);
    	else if(otm.getMulop() instanceof MulopDiv) Code.put(Code.div);
    	else if(otm.getMulop() instanceof MulopPercent) Code.put(Code.rem);
    }
    
    /**********************FACTOR*****************************/
    /**
     * FactorDesignator ::= (FactorDesignator) Designator;
		Factor ::= (FactorDesign) FactorDesignator AdditionalParentheses
					|
					(FactorNum) NUMCONST:val
					|
					(FactorChar) CHARCONST:val
					|
					(FactorBool) BOOLCONST:val
					|
					(FactorNew) NEW Type OrExprActPars
					|
					(FactorExpr) LPAREN Expr RPAREN
					;
	   AdditionalParentheses ::= (AddParen) LPAREN AdditionalActParOp RPAREN
					|
					(NoAddParen) \/*epsilon*\/
					;
     */
    
    public void visit(FactorNum fn) {
    	Code.loadConst(fn.getVal());
    }
    
    public void visit(FactorChar fc) {
    	Code.loadConst((int)fc.getVal());
    }
    
    public void visit(FactorBool fb) {
    	Code.loadConst((fb.getVal()==true)?1:0);
    }
    
    public void visit(FactorIdent fi) {
    	Code.load(fi.getDesignator().obj);
    }
    
    private Stack<Obj> stekPozvanihFunkcija=new Stack<>();//
    public void visit(FactorDesignator fd) {
    	
    }
    public void visit(FactorNew fn) {
    	Code.put(Code.newarray);
    	if(fn.struct.getElemType()==Tab.charType) Code.put(0);
    	else Code.put(1);
    }
    /*********************************DESIGNATOR***********************************/
    /**
     * Designator ::= (DesignatorM) DesignatorMatched
				|
				(DesignatorU) DesignatorUnmatched
			    ;

				DesPom ::= (DesPom) IDENT:name;
				DesignatorMatched ::= (DesMatch) DesPom OptionalDesignatorOpp;
				DesignatorUnmatched ::= (DesUnmatch) DesUnmatchFlag DesignatorMatched;
				
				OptionalDesignatorOpp ::= (OptDesignOpp) OptionalDesignatorOpp OrIdentExpr
										  |
										  (NoOptDesignOpp) \/*epsilon*\/
										  ;
				OrIdentExpr ::= (OrIdent) DOT IDENT:iden
								|
								(OrExpr) LSQUARE Expr RSQUARE
								;	
				DesUnmatchFlag ::= (DesUnmatchFlag) IDENT:name COLON COLON ;
     */
    
    
    public void visit(DesPom ds) {
    	SyntaxNode par=((DesMatch)ds.getParent()).getParent();
    	if(/////VRV OVD IMA NEKA GRESKA !!!!!!!!!!!!!!!!!!!---Treba dodati vrv proveru da li je designatorStatement u drugom delu fora za ovo jer se on izvrsava nakon for petlje
    			(ds.obj.getKind()==Obj.Meth && listaMetodaUKlasama.contains(ds.obj) && par instanceof FactorDesignator)
    			||
    			(ds.obj.getKind()==Obj.Fld && (par instanceof DesignatorM || par instanceof DesUnmatch || par instanceof DesStmtE ))
    	  ) {
    		Code.put(Code.load_n+0);
    	}
    }
    
    public void visit(OptDesignOpp odo) {
    	OrIdentExpr orIdentExpr=odo.getOrIdentExpr();
    	if(orIdentExpr.getClass()==OrIdent.class) {//a.b.b.bb.
    		Code.load(odo.getOptionalDesignatorOpp().obj);
    	}else if(orIdentExpr.getClass()==OrExpr.class) {//a.b[c]
    	    //Code.load(odo.getOptionalDesignatorOpp().obj);//ovo treba prepraviti nesto mi ugrozava pythonList
    	}
    }
    
    //!!!!!!!!!!!!!!!!!!TREBA DOPUNITI
    public void visit(NoOptDesignOpp nodo) {
    	
    }
    
    
    /*********************************DESIGNATOR STATEMENT*************************/
    //POZIV FUNKCIJE
    /**
     * DesignatorStatement ::= (DesStmtE) Designator OrDesStmt
						|
						(DesStmtH) LSQUARE OptionalDesignComma MUL Designator RSQUARE EQUALS Designator
						;

		OrDesStmt ::= (OrAssignExpr) Assignop Expr
					  |
					  (OrActPars) PomDesAddStek LPAREN AdditionalActPars RPAREN
					  |
					  (OrIncrement) INCREMENT
					  |
					  (OrDecrement) DECREMENT
					  ;
		OptionalDesignComma ::= (OptDesCom) OptionalDesignComma AdditionalDesign COMMA
						|
						(NooOptDesCom) \/*epsilon*\/
						;
		AdditionalDesign ::= (AdditionalDes) Designator
					 |
					 (NoAdditionalDes) \/*epsilon*\/
					 ;
	     */
    
    public void pozivGlobalneFunkcije(Obj obj) {
    	String name=obj.getName();
    	
    	if(name.equalsIgnoreCase("len")) {
    		Code.put(Code.arraylength);
    		return;
    	}
    	
    	if(name.equalsIgnoreCase("ord")) {
    		return;
    	}
    	
    	if(name.equals("chr")) {
    		return;
    	}
    	
    	Code.put(Code.call);
    	//racunanje adrese funkcije
    	int adr=obj.getAdr();
    	Code.put2(adr-Code.pc+1);//offset za koliko da se pomerimo da bi stigli na pocetak funkcije
    }
    public void visit(DesStmtE dse) {
    	if(dse.getOrDesStmt().getClass()==OrActPars.class) {
    		Obj funcDesig=dse.getDesignator().obj;
    		//treba dodati poziv funkcije za metode!!!!!!!!!!!!!!!!!!!!!
    		//kad ispravlkjas ovo stavi u else deo
    		pozivGlobalneFunkcije(funcDesig);
    		//posto se kod designator statementa povratna vrednost funkcije ne dodeljuje povratnu
    		//vrednost samo skidamo sa steka
    		if(dse.getDesignator().obj.getType()!=Tab.noType) {
    			Code.put(Code.pop);
    		}
    		//stekPozvanihFunkcija.pop(); kasnije
    	}else if(dse.getOrDesStmt().getClass()==OrAssignExpr.class) {
    		Code.store(dse.getDesignator().obj);
    	}else if(dse.getOrDesStmt().getClass()==OrIncrement.class) {
    		if(dse.getDesignator().obj.getKind()==Obj.Fld) {
    			Code.put(Code.dup);
    		}else if(dse.getDesignator().obj.getKind()==Obj.Elem) {
    			Code.put(Code.dup2);
    		}
    		Code.load(dse.getDesignator().obj);
    		Code.loadConst(1);
    		Code.put(Code.add);
    		Code.store(dse.getDesignator().obj);
    	}else if(dse.getOrDesStmt().getClass()==OrDecrement.class) {
    		if(dse.getDesignator().obj.getKind()==Obj.Fld) {
    			Code.put(Code.dup);
    		}else if(dse.getDesignator().obj.getKind()==Obj.Elem) {
    			Code.put(Code.dup2);
    		}
    		Code.load(dse.getDesignator().obj);
    		Code.loadConst(1);
    		Code.put(Code.sub);
    		Code.store(dse.getDesignator().obj);
    	}
    }
    
    List<Obj> pythonList=new ArrayList<>();
    public void visit(AdditionalDes ad) {
    	pythonList.add(ad.getDesignator().obj);
    }
    
    public void visit(NoAdditionalDes nad) {
    	pythonList.add(null);
    }
    
    public void visit(DesStmtH dsh) {
    	//prvo treba uporediti da li je duzina elemenata prve liste + poslednji niz jednala
    	//duzini niza sa druge strane =
    	//duzina leve strane
    	for(Obj o:pythonList) {
    		if(o.getType().getKind()==Struct.Array) {
    			Code.load(o);
    			Code.put(Code.arraylength);
    			break;
    		}
    	}
    	Code.loadConst(pythonList.size()-1);
    	Code.put(Code.add);
    	//duzina desne strane
    	Code.load(dsh.getDesignator().obj);
    	Code.put(Code.arraylength);
    	//ako je duzina ok skoci,, u suprotnom treap
    	Code.put(Code.jcc+Code.le);
    	Code.put2(5);
    	Code.put(2);
    	
    	int curr=0;
    	int elemCnt=0;
    	for(Obj obj:pythonList) {
    		if(obj!=null && obj.getType().getKind()!=Struct.Array) {
    			Code.load(dsh.getDesignator1().obj);
    			Code.loadConst(pythonList.indexOf(obj));
    			Code.put(Code.aload);
    			Code.store(obj);
    			curr+=1;
    			elemCnt+=1;
    		}
    		if(obj!=null && obj.getType().getKind()==Struct.Array) {
    			Code.load(obj);
    			Code.put(curr-elemCnt);
    			Code.load(dsh.getDesignator1().obj);
    			Code.loadConst(curr);
    			Code.put(Code.aload);
    			curr+=1;
    			Code.put(Code.astore);
    			
    		}
    	}
    	pythonList.clear();
    }
    
    /***********************CLASS DECL**************************/
    
    /**
     * ClassDecl ::= (ClassDeclaration) ClassDeclBegin LBRACE ClassBody RBRACE;

			ClassDeclBegin ::= (ClassDeclBegin) CLASS IDENT:name AdditionalExtends;
			
			ClassBody ::= (ClassMatch) ClassMat
						  |
						  (ClassUnmatch) ClassUnmat
						  ;
			ClassMat ::= (ClassM) OptionalStatic OptionalVarDecl AdditionalMethodClassDecl;
			ClassUnmat ::= (ClassU) OptionalStatic OptionalStaticInitializer OptionalVarDecl AdditionalMethodClassDecl;
			
						   
			AdditionalExtends ::= (AdditionalExtend) EXTENDS Type:type
								  |
								  (NoAdditionalExtend) \/*epsilon*\/
								  ;
			OptionalStatic ::= (OptionalStat) OptionalStatic STATIC VarDeclStatic
							   |
							   (NoOptionalStatic) \/*epsilon*\/
							   ;
			OptionalVarDecl ::= (OptVarDecl) OptionalVarDecl VarDeclClass
								|
								(NoOptVarDecl) \/*epsilon*\/
								;
			
			AdditionalMethodClassDecl ::= (AddClassMeth) LBRACE MethodDeclClassList RBRACE
										  |
										  (NoAddClassMeth) \/*epsilon*\/
										  ;
     */
    
       Obj currClass=null;
       HashMap<Obj,Integer> hashOfClasses=new HashMap<>();
       
	   public void visit(ClassDeclBegin cb) {
		   this.currClass=cb.obj;
	   }
	   
	   public void visit(ClassDeclaration cd) {
		   //kad obidjemo celu klasu stavljamo je u hash mapu
		   hashOfClasses.put(currClass, -1); currClass=null;  
	   }
	
	   /************************FOR_PETLJA*****************************/
	   /**
	    * 
	    * Matched ::= (DesStm) DesignatorStatement SEMICOLON
			|
			(IfElseMatched) IF IfBegin Condition IfEpsilon RPAREN Matched ELSE Matched
			|
			(StmtBreak) BREAK SEMICOLON
			|
			(StmtContinue) CONTINUE SEMICOLON
			|
			(StmtReturn) RETURN AdditionalExpr SEMICOLON
			|
			(StmtRead) READ LPAREN Designator RPAREN SEMICOLON
			|
			(StmtPrint) PRINT LPAREN Expr AdditionalPrintNum RPAREN SEMICOLON
			|
			(StmtFor) ForBegin Matched ForEnd
			|
			(StmtFor2) ForBegin Unmatched ForEnd
			|
			(StmtStmt) LBRACE StatementList RBRACE
			;
	
		ForBegin ::= (ForBegin)	FOR LPAREN AdditionalDesignatoStmtList SEMICOLON AdditionalCondFact SEMICOLON AdditionalDesignatoStmtList RPAREN;
		ForEnd ::= (ForEnd) \/*epsilon*\/;
	    */
	   
	   //PATCHING STACKS
	   Stack<Integer> forS=new Stack<>();
	   Stack<List<Integer>> breakS=new Stack<>();
	   Stack<List<Integer>> elseS=new Stack<>();
	   Stack<List<Integer>> andS=new Stack<>();
	   Stack<List<Integer>> orS=new Stack<>();
	   
	   public void visit(LoopStart fs) {
		   //postavljanje trenutne vrednosti pc-ija jer ce se na njega ponovo skakati
		   //dok je ispunjen uslov na pocetku petlje
		   forS.push(Code.pc);
		   //pregrade
		   andS.push(new ArrayList<>());
		   orS.push(new ArrayList<>());
		   elseS.push(new ArrayList<>());
		   breakS.push(new ArrayList<>());
	   }
	   
	   public void visit(ForBegin fb) {
		   
		   
		   
		   
		   
	   }
	   
	   public void visit(StmtFor sf) {
		   List<Integer> orList=orS.pop();
		   List<Integer> andList=andS.pop();
		   List<Integer> breakList=breakS.pop();
		   List<Integer> elseList=elseS.pop();
		   Code.putJump(forS.pop());//vracamo se na pocetak for petlje
		   
		   for(Integer a:andList) {
			   Code.fixup(a);//patch
		   }
		   
		   for(Integer b:breakList) {
			   Code.fixup(b);//patch
		   }
	   }
	   
	   public void visit(StmtFor2 sf2) {
		   List<Integer> orList=orS.pop();
		   List<Integer> andList=andS.pop();
		   List<Integer> breakList=breakS.pop();
		   List<Integer> elseList=elseS.pop();
		   Code.putJump(forS.pop());//vracamo se na pcetak for petlje
		   
		   for(Integer a:andList) {
			   Code.fixup(a);//patch
		   }
		   
		   for(Integer b:breakList) {
			   Code.fixup(b);//patch
		   }
	   }
	   /************************BREAK*********************************/
	   public void visit(StmtBreak sb) {
		   //ovde ne znamo trenutno gde je kraj, pa cemo kasnije patchovati
		   List<Integer> breakList=breakS.pop();
		   breakList.add(Code.pc+1);
		   breakS.push(breakList);
		   
		   
		   Code.putJump(0);//kasnije stavljamo stvarnu adresu skoka
		   
	   }
	   /************************CONTINUE*****************************/
	   public void visit(StmtContinue sc) {
		   Code.putJump(forS.peek());
	   }
	   
	   /***********************COND TERM*****************************/
	   /**
	    * 
	    */
	   
	   /************************CONDITION****************************/
	   /**
	    * Condition ::= (Condition) CondTerm OptionalCondTerm;

			OptionalCondTerm ::= (OptCondTerm) OptionalCondTerm OR CondTerm
								  |
								  (NoOptCondTerm) \/*epsilon*\/
								  ;
	    */
	   /***********************COND FACT****************************/
	   /**
	    * CondFact ::= (CondFact) Expr AdditionalRelopExpr;

			AdditionalRelopExpr ::= (AddRelopExpr) Relop Expr
									|
									(NoAddRelopExpr) \/*epsilon*\/
									;
			Relop ::= (RelEqEq) EQUALS_EQUALS
		  |
		  (RelNotEq) NOT_EQUALS
		  |
		  (RelGrt) GT
		  |
		  (RelGrtEq) GTE
		  |
		  (RelLt) LT
		  |
		  (RelLtEq) LTE
		  ;		
						
	    */
	   public void visit(AddRelopExpr are) {
		   List<Integer> andList=andS.pop();
		   andList.add(Code.pc+1);
		   andS.push(andList);
		   Relop relop=are.getRelop();
		   //postavlamo adrese na 0 pa ih kasnije patchujem
		   if(relop.getClass()==RelEqEq.class) {
			   Code.putFalseJump(Code.eq, 0);
		   }else if(relop.getClass()==RelNotEq.class) {
			   Code.putFalseJump(Code.ne, 0);
		   }else if(relop.getClass()==RelGrt.class) {
			   Code.putFalseJump(Code.gt, 0);
		   }else if(relop.getClass()==RelGrtEq.class) {
			   Code.putFalseJump(Code.ge, 0);
		   }else if(relop.getClass()==RelLt.class) {
			   Code.putFalseJump(Code.lt, 0);
		   }else if(relop.getClass()==RelLtEq.class) {
			   Code.putFalseJump(Code.le, 0);
		   }
		   
	   }
	   
	   public void visit(NoAddRelopExpr nae) {
		   Code.loadConst(1);//for(;true;){}
		   List<Integer> andLista=andS.pop();
		   andLista.add(Code.pc+1);
		   andS.push(andLista);
		   Code.putFalseJump(Code.eq, 0);//fromalno patch iako ne iskacemo
	   }
	   
	   
	   
}
