package rs.ac.bg.etf.pp1;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Stack;

import javax.swing.text.StyledEditorKit;

import org.apache.log4j.Logger;
import rs.ac.bg.etf.pp1.ast.*;
import rs.etf.pp1.symboltable.*;
import rs.etf.pp1.symboltable.concepts.*;

public class SemanticAnalyzer extends VisitorAdaptor {

	public static int nVars;
	
	public static Struct booleanType = new Struct(Struct.Bool);
	public static final int Namespace=7;
	
	boolean errorDetected = false;
	Logger log=Logger.getLogger(getClass());
	
	private HashMap<Struct,String> klase=new HashMap<>();
	
	private Struct currType=null;
	private Struct natklasaTip=null;
	private String natklasaIme="";
	private Struct potklasaTip=null;
	private String potklasaIme="";
	private String currMethIme="";
	private Obj currMethType=null;
	private Obj nadjacanObj=null;
	private Integer brojParametara=0;
	private Boolean returnStmt=false;
	
	
	public SemanticAnalyzer() {
		Tab.currentScope.addToLocals(new Obj(Obj.Type, "bool", booleanType));
	}
	
	
	public void report_error(String message, SyntaxNode info) {
		errorDetected = true;
		StringBuilder msg = new StringBuilder(message);
		int line = (info == null) ? 0: info.getLine();
		if (line != 0)
			msg.append (" na liniji ").append(line);
		log.error(msg.toString());
	}

	public void report_info(String message, SyntaxNode info) {
		StringBuilder msg = new StringBuilder(message); 
		int line = (info == null) ? 0: info.getLine();
		if (line != 0)
			msg.append (" na liniji ").append(line);
		log.info(msg.toString());
	}
	/************************ PROGRAM ******************************/
	/**
	 * Program ::= (Program) PROGRAM ProgName:p NamespaceList ConstDeclList LBRACE MethodDeclList RBRACE;

	   ProgName ::= (ProgName) IDENT:progName;
	 */
	
	public void visit(ProgName progName) {
		//obj.vrsta
		//naziv labele za IDENT programa sto smo stavili u mjparser
		//tab.type
		progName.obj=Tab.insert(Obj.Prog, progName.getProgName(), Tab.noType);
		Tab.openScope();
	}
	
	public void visit(Program program) {
		nVars = Tab.currentScope.getnVars();
		Tab.chainLocalSymbols(program.getProgName().obj);
		Tab.closeScope();
	}
	
	/*********************** TYPE  *************************/
	/**
	 * 
	 * Type ::= (TypeOptDoubleColon) IDENT COLON COLON IDENT:typeName
		 		|
		 		(TypeBaseNoColon) IDENT:typeName
		 		;
	 */
	public void visit(TypeOptDoubleColon type) {
		String tip=type.getTypeName();
		Obj obj=Tab.find(tip);
		if(obj!=Tab.noObj) {
			if(obj.getKind()==Obj.Type) {
				//report_info("Tip: "+tip+" je definisan", type);
				type.struct=obj.getType();
				currType=type.struct;
			}else {
				report_error("GRESKA:Postoji naziv: "+tip+" u tabeli, ali on ne predstavja tip",type);
			}
		}else {
			report_error("GRESKA:Tip sa name-om: "+tip+" nije definisan u nijednom scope-u.", type);
		}
	}
	
	public void visit(TypeBaseNoColon type) {
		String name=type.getTypeName();
		Obj obj=Tab.find(name);
		
		if(obj==Tab.noObj) {
			report_error("GRESKA:Tip sa name-om: "+name+" nije definisan u nijednom scope-u.", type);
		}else {
			if(obj.getKind()==Obj.Type) {
				//report_info("Tip: "+name+" je definisan", type);
				type.struct=obj.getType();
				currType=type.struct;
			}else {
				report_error("GRESKA:Postoji naziv: "+name+" u tabeli, ali on ne predstavja tip",type);
			}
		}
	}
	
	/************************* PROMENJLJIVE *****************************/
	/**
	 * ConstType ::= (ConstNum) NUMCONST:val
			  |
			  (ConstChar) CHARCONST:val
			  |
			  (ConstBool) BOOLCONST:val
			  ;
	 */
	//NUMCONST
	
	public void visit(ConstNum number) {
		number.struct=Tab.intType;
	}
	
	//CharConst
	public void visit(ConstChar charC) {
		charC.struct=Tab.charType;
	}
	
	//BoolConst
	public void visit(ConstBool boolC) {
		boolC.struct=booleanType;// ja sam napravio ovaj simbol i dodao u universe, pa da ne trazim kad je vec lokalno sacuvan
	}
	
	/*Konstavne*/
	//Provera valjanosti tipa i vrednosti
	/**
	 * ConstDecl ::= (ConstDecl) CONST Type IDENT:name EQUALS ConstType ConstDeclTail SEMICOLON;
	 */
	public void visit(ConstDecl cnstDecl) {
		//1. provera da li je konstanta vec deklarisana
		String name=cnstDecl.getName();
		Obj obj=Tab.find(name);
		if(obj!=Tab.noObj) {
			//greska, promenjljiva je deklarisan vec
			report_error("GRESKA:Promenjljiva: "+name+" je vec deklarisan!",cnstDecl);
			return;
		}
		
		//2. provera da li su type i dodeljena vrednost kompatiblni(assignable)
		
		Struct type=cnstDecl.getType().struct; //za struct nema geter nego se to dir. dohvata jer je public
		Struct cnst=cnstDecl.getConstType().struct;
		//currType=type;
		
		if(!cnst.assignableTo(type)) {
			report_error("GRESKA:Tip i vrednost su nekompatibilni!", cnstDecl);
			return;
		}
		
		//Sad je sve u redu, ubacujemo konstantu u tabelu simbola
		
		Obj objInsert=Tab.insert(Obj.Con,name,type);
		report_info("Definisana je konstanta: "+name, cnstDecl);
		
		ConstType ct = cnstDecl.getConstType();
    	
    	if (ct.getClass() == ConstNum.class) {
    		objInsert.setAdr(((ConstNum) ct).getVal());
    	} else if (ct.getClass() == ConstChar.class) {
    		objInsert.setAdr(((ConstChar) ct).getVal());
    	} else if (ct.getClass() == ConstBool.class) {
    		objInsert.setAdr(((ConstBool) ct).getVal() == true ? 1 : 0);
    	}
		
	}
	
	public void visit(ConstDeclHead cnstDecl) {
		String name=cnstDecl.getName();
		Obj obj=Tab.find(name);
		
		//1. provera da li je konstanta vec deklarisana
		if(obj!=Tab.noObj) {
			//greska, promenjljiva je deklarisan vec
			report_error("GRESKA:Promenjljiva: "+name+" je vec deklarisan!",cnstDecl);
			return;
		}
		
		//2. provera da li su type i dodeljena vrednost kompatiblni(assignable)
		Struct cnstType=cnstDecl.getConstType().struct;
		
		if(!cnstType.assignableTo(currType)) {
			report_error("GRESKA:Tip i vrednost su nekompatibilni!", cnstDecl);
			return;
		}
		
		Obj objInsert=Tab.insert(Obj.Con,name,cnstType);
		report_info("Definisana je konstanta: "+name, cnstDecl);
		
		ConstType ct = cnstDecl.getConstType();
    	
    	if (ct.getClass() == ConstNum.class) {
    		objInsert.setAdr(((ConstNum) ct).getVal());
    		//report_info("Definisana je konstanta: "+name+"ADR: "+obj.getAdr(), cnstDecl);
    	} else if (ct.getClass() == ConstChar.class) {
    		objInsert.setAdr(((ConstChar) ct).getVal());
    	} else if (ct.getClass() == ConstBool.class) {
    		objInsert.setAdr(((ConstBool) ct).getVal() == true ? 1 : 0);
    	}
			
	}
	
	/*Vars*/
	
	//globalne
	/**
	 * VarDecl ::= (VarDecl) Type NewVarDecl OptionalVarDeclList SEMICOLON;

	   NewVarDecl ::= (VarDeclIdent) IDENT:name AdditionalSquare;
	 */
	public void visit(VarDecl varDecl) {
		String name=((VarDeclIdent)varDecl.getNewVarDecl()).getName();
		Obj obj=Tab.find(name);
		
		//ako se promenjljiva sa istim imenom nalazi vec deklarisana ovde, onda je to greska
		if(obj!=Tab.noObj && Tab.currentScope.findSymbol(name)!=null) {
			report_error("GRESKA:Globalna promenljiva sa nazivom: "+name+" je vec deklarisana u currentScope-u.",varDecl);
			return;
		}
		
		String tip=((VarDeclIdent)varDecl.getNewVarDecl()).getAdditionalSquare().obj.getName();
		if("epsilon".equals(tip)) {
			report_info("Globalna promenljiva: "+name+" je dodata u tabelu simbola.", varDecl);
			Tab.insert(Obj.Var, name, currType);
		}else if("[]".equals(tip)) {
			report_info("Globalna promenjliva tipa niz: "+name+" je dodata u tableu simbola.",varDecl);
			Tab.insert(Obj.Var, name, new Struct(Struct.Array,currType));
		}else {
			report_error("Desia se greska promenjliva nije ni niz ni obicna.", varDecl);
		}
		
		return;
	}
	
	public void visit(AdditionalS addit) {
		addit.obj=new Obj(-1, "[]", null);
	}
	public void visit(NoAdditionalS noAddit) {
		noAddit.obj=new Obj(-1,"epsilon",null);
	}
	
	/**
	 * 
	 * OptionalVarDeclList ::= (OptionalVarList) OptionalVarDeclList COMMA NewVarDecl
	*					|
	*					(NoOptionalVarList) \/*epsilon*\/
	*					
	 * 
	 */
	
	public void visit(OptionalVarList ovarDecl) {
		String name=((VarDeclIdent)ovarDecl.getNewVarDecl()).getName();
		Obj obj=Tab.find(name);
		
		//ako se promenjljiva sa istim imenom nalazi vec deklarisana ovde, onda je to greska
		if(obj!=Tab.noObj && Tab.currentScope.findSymbol(name)!=null) {
			report_error("GRESKA:Globalna promenljiva sa nazivom: "+name+" je vec deklarisana u currentScope-u.",ovarDecl);
			return;
		}
		
		String tip=((VarDeclIdent)ovarDecl.getNewVarDecl()).getAdditionalSquare().obj.getName();
		if("epsilon".equals(tip)) {
			report_info("Globalna promenljiva: "+name+" je dodata u tabelu simbola.", ovarDecl);
			Tab.insert(Obj.Var, name, currType);
		}else if("[]".equals(tip)) {
			report_info("Globalna promenjliva tipa niz: "+name+" je dodata u tableu simbola.",ovarDecl);
			Tab.insert(Obj.Var, name, new Struct(Struct.Array,currType));
		}else {
			report_error("Desia se greska promenjliva nije ni niz ni obicna.", ovarDecl);
		}
		
		return;
	}
	
	//class
	/**
	 * 
	 * ClassDecl ::= (ClassDeclaration) ClassDeclBegin LBRACE ClassBody RBRACE;

		ClassDeclBegin ::= (ClassDeclBegin) CLASS IDENT:name AdditionalExtends;
		
		ClassBody ::= (ClassMatch) ClassMat
					  |
					  (ClassUnmatch) ClassUnmat
					  ;
		ClassMat ::= (ClassM) OptionalStatic OptionalVarDecl AdditionalMethodClassDecl;
		ClassUnmat ::= (ClassU) OptionalStatic OptionalStaticInitializer OptionalVarDecl AdditionalMethodClassDecl;
		
					   
		AdditionalExtends ::= (AdditionalExtend) EXTENDS Type:type
							  |
							  (NoAdditionalExtend) \/*epsilon*\/
							  ;
		OptionalStatic ::= (OptionalStat) OptionalStatic STATIC VarDeclStatic
						   |
						   (NoOptionalStatic) \/*epsilon*\/
						   ;
		OptionalVarDecl ::= (OptVarDecl) OptionalVarDecl VarDeclClass
							|
							(NoOptVarDecl) \/*epsilon*\/
							;
		
		AdditionalMethodClassDecl ::= (AddClassMeth) LBRACE MethodDeclList RBRACE
									  |
									  (NoAddClassMeth) \/* epsilon*\/
									  ;
	 * 
	 */
	
	
	public void visit(VarDeclClass varClass) {
		String name=((VarDeclIdent)varClass.getNewVarDecl()).getName();
		Obj obj=Tab.find(name);
		//ako se promenjljiva sa istim imenom nalazi vec deklarisana ovde, onda je to greska
		if(obj!=Tab.noObj && Tab.currentScope.findSymbol(name)!=null) {
			report_error("GRESKA:Promenljiva sa nazivom: "+name+" je vec deklarisana u currentScope-u.",varClass);
			return;
		}
		
		String tip=((VarDeclIdent)varClass.getNewVarDecl()).getAdditionalSquare().obj.getName();
		if("epsilon".equals(tip)) {
			report_info("Promenljiva: "+name+" je dodata u tabelu simbola.", varClass);
			Tab.insert(Obj.Fld, name, currType);
		}else if("[]".equals(tip)) {
			report_info("Promenjliva tipa niz: "+name+" je dodata u tableu simbola.",varClass);
			Tab.insert(Obj.Fld, name, new Struct(Struct.Array,currType));
		}else {
			report_error("Desia se greska promenjliva nije ni niz ni obicna.", varClass);
		}
		
		return;
	}
	
	public void visit(OptionalVarListClass ovarClass) {
		String name=((VarDeclIdent)ovarClass.getNewVarDecl()).getName();
		Obj obj=Tab.find(name);
		//ako se promenjljiva sa istim imenom nalazi vec deklarisana ovde, onda je to greska
		if(obj!=Tab.noObj && Tab.currentScope.findSymbol(name)!=null) {
			report_error("GRESKA:Promenljiva sa nazivom: "+name+" je vec deklarisana u currentScope-u.",ovarClass);
			return;
		}
		
		String tip=((VarDeclIdent)ovarClass.getNewVarDecl()).getAdditionalSquare().obj.getName();
		if("epsilon".equals(tip)) {
			report_info("Promenljiva: "+name+" je dodata u tabelu simbola.", ovarClass);
			Tab.insert(Obj.Fld, name, currType);
		}else if("[]".equals(tip)) {
			report_info("Promenjliva tipa niz: "+name+" je dodata u tableu simbola.",ovarClass);
			Tab.insert(Obj.Fld, name, new Struct(Struct.Array,currType));
		}else {
			report_error("Desia se greska promenjliva nije ni niz ni obicna.", ovarClass);
		}
		
		return;
	}
	
	
	
	//lokalne promenjljive u metodima
	/**
	 * 
	 * VarDeclMeth ::= (VarDeclMeth) Type NewVarDecl OptionalVarDeclListMeth SEMICOLON;
	OptionalVarDeclListMeth ::= (OptionalVarListMeth) OptionalVarDeclListMeth COMMA NewVarDecl
						|
						(NoOptionalVarListMeth) \/*epsilon*\/
						;
	 * 
	 */
	
	public void visit(VarDeclMeth varMeth) {
		String name=((VarDeclIdent)varMeth.getNewVarDecl()).getName();
		Obj obj=Tab.find(name);
		//ako se promenjljiva sa istim imenom nalazi vec deklarisana ovde, onda je to greska
		if(obj!=Tab.noObj && Tab.currentScope.findSymbol(name)!=null) {
			report_error("GRESKA:Promenljiva sa nazivom: "+name+" je vec deklarisana u currentScope-u.",varMeth);
			return;
		}
		
		String tip=((VarDeclIdent)varMeth.getNewVarDecl()).getAdditionalSquare().obj.getName();
		if("epsilon".equals(tip)) {
			report_info("Promenljiva: "+name+" je dodata u tabelu simbola.", varMeth);
			Tab.insert(Obj.Var, name, currType);
		}else if("[]".equals(tip)) {
			report_info("Promenjliva tipa niz: "+name+" je dodata u tableu simbola.",varMeth);
			Tab.insert(Obj.Var, name, new Struct(Struct.Array,currType));
		}else {
			report_error("Desia se greska promenjliva nije ni niz ni obicna.", varMeth);
		}
		
		return;
	}
	
	public void visit(OptionalVarListMeth ovarMeth) {
		String name=((VarDeclIdent)ovarMeth.getNewVarDecl()).getName();
		Obj obj=Tab.find(name);
		//ako se promenjljiva sa istim imenom nalazi vec deklarisana ovde, onda je to greska
		if(obj!=Tab.noObj && Tab.currentScope.findSymbol(name)!=null) {
			report_error("GRESKA:Promenljiva sa nazivom: "+name+" je vec deklarisana u currentScope-u.",ovarMeth);
			return;
		}
		
		String tip=((VarDeclIdent)ovarMeth.getNewVarDecl()).getAdditionalSquare().obj.getName();
		if("epsilon".equals(tip)) {
			report_info("Promenljiva: "+name+" je dodata u tabelu simbola.", ovarMeth);
			Tab.insert(Obj.Var, name, currType);
		}else if("[]".equals(tip)) {
			report_info("Promenjliva tipa niz: "+name+" je dodata u tableu simbola.",ovarMeth);
			Tab.insert(Obj.Var, name, new Struct(Struct.Array,currType));
		}else {
			report_error("Desia se greska promenjliva nije ni niz ni obicna.", ovarMeth);
		}
		
		return;
	}
	
	//ostalo je staticke metoe i metode namespace da se implementiraju(za namespace treba dodatno ispraviti mjparser)
	
	/*********************CLASS DECL ********************************/
	/**
	 * ClassDecl ::= (ClassDeclaration) CLASS IDENT:name AdditionalExtends LBRACE ClassBody RBRACE;
	 * AdditionalExtends ::= (AdditionalExtend) EXTENDS Type:type
					  |
					  (NoAdditionalExtend) \/*epsilon*\/
					  ;
	 */
	
	public void visit(ClassDeclBegin classDecl) {
		String name=classDecl.getName();
		
		Obj classExists=Tab.find(name);
		
		if(classExists!=Tab.noObj) {
			report_error("Vec je deklarisana klasa sa imenom: "+name,classDecl);
			return;
		}
		
		natklasaTip=classDecl.getAdditionalExtends().struct;
		
		natklasaIme=klase.getOrDefault(natklasaTip, null);
		potklasaIme=name;
		//potklasaTip=new Struct(Struct.Class,natklasaTip);-zamena
		potklasaTip=new Struct(Struct.Class);
		potklasaTip.setElementType(natklasaTip);
		report_info("Dodata KLASA: "+name+" u tabelu simbola", classDecl);
		classDecl.obj=Tab.insert(Obj.Type, name, potklasaTip);
		Tab.openScope();
		
		if(natklasaTip!=null) {
			//ako postoji natklasa
			String extensionType=((TypeBaseNoColon)((AdditionalExtend)classDecl.getAdditionalExtends()).getType()).getTypeName();
			Obj extType=Tab.find(extensionType);
			
			if(extType==Tab.noObj) {
				//ako ne postoji zadati indentifikator, to znaci da tip jos uvek nije definisan
				report_error("Ne postoji natklasa sa imenom: "+ name, classDecl);
				return;
			}else {
				if(klase.getOrDefault(extType.getType(), null)==null) {
					report_error("Ne postoji zadata natklasa,ona je neki drugi tip, ane klasa",classDecl);
					return;
				}
			}		
		}
		
		if(natklasaTip!=null) {
			for(Obj obj:natklasaTip.getMembers()) {
				if(obj.getName().equals(natklasaIme)) {
					continue;
				}
				if(obj.getKind()==Obj.Fld) {
					Tab.insert(Obj.Fld, obj.getName(), obj.getType());
				}else if(obj.getKind()==Obj.Meth) {
					//!!!!!!!!!!!!!!!treba jos neki uslovi kasnije da se dodaju ovde !!!!!!!!!!!
					Tab.insert(Obj.Meth, obj.getName(), obj.getType());
				}
			}
		}
		
		
	}
	
	public void visit(ClassDeclaration classDecl) {
		
		//!!!!!!!!!!vrv ovde treba dodati provere i ubacivanje statickih polja!!!!!!
		klase.put(potklasaTip, potklasaIme);
		Tab.chainLocalSymbols(potklasaTip);
		Tab.closeScope();
		potklasaIme="";
		natklasaIme="";
		potklasaTip=null;
		natklasaTip=null;
	    
	}
	
	public void visit(AdditionalExtend ae) {
		ae.struct=ae.getType().struct;
	}
	
	public void visit(NoAdditionalExtend nae) {
		nae.struct=null;
	}
	
	/**************************METODE*******************/
	//globalna deklaracija Metoda
	public void visit(TypeOpt type) {
		
		String name=currMethIme=type.getName();
		//ukoliko je u currentScope-u vec definisana metoda sa tim imenom,a ovo nije potkalsa GRESKA
		if(Tab.currentScope().findSymbol(name)!=null && potklasaTip==null) {
			report_error("Metoda: "+name+" je vec deklarisana.",type);
			currMethType=Tab.noObj;type.obj=Tab.noObj;
			Tab.openScope();
			return;
		}else if(Tab.currentScope().findSymbol(name)!=null) {
			//u suprotnom ako je ovo potklasa a metod redefinisan dodajemo redefinisan metod,a brisemo nasledjen
			nadjacanObj=Tab.currentScope().findSymbol(name);
			Tab.currentScope().getLocals().deleteKey(name);
		}
		
		currMethType=Tab.insert(Obj.Meth, name, type.getType().struct);
		type.obj=currMethType;
		Tab.openScope();
		
		if(potklasaTip!=null) {
			//ako je metod klase moramo da dodamo this
			brojParametara++;
			report_info("Dodata metoda klase: "+name+" klase "+potklasaIme, type);
			Tab.insert(Obj.Var, "this", potklasaTip);
			return;
		}
		report_info("Dodata metoda koja je globalna", type);
		
	}
	
	public void visit(VoidOpt type) {
		String name=currMethIme=type.getName();
		//ukoliko je u currentScope-u vec definisana metoda sa tim imenom,a ovo nije potkalsa GRESKA
		if(Tab.currentScope().findSymbol(name)!=null && potklasaTip==null) {
			report_error("Metoda: "+name+" je vec deklarisana.",type);
			currMethType=Tab.noObj;type.obj=Tab.noObj;
			Tab.openScope();
			return;
		}else if(Tab.currentScope().findSymbol(name)!=null) {
			//u suprotnom ako je ovo potklasa a metod redefinisan dodajemo redefinisan metod,a brisemo nasledjen
			nadjacanObj=Tab.currentScope().findSymbol(name);
			Tab.currentScope().getLocals().deleteKey(name);
		}
		
		currMethType=Tab.insert(Obj.Meth, name, Tab.noType);
		type.obj=currMethType;
		Tab.openScope();
		
		if(potklasaTip!=null) {
			//ako je metod klase moramo da dodamo this
			brojParametara++;
			report_info("Dodata metoda klase: "+name+" klase "+potklasaIme, type);
			Tab.insert(Obj.Var, "this", potklasaTip);
			return;
		}
		report_info("Dodata metoda koja je globalna", type);
	}
	
	public void visit(MethodDecl methodDecl) {
		methodDecl.obj=currMethType;
		//provera da li main ima argumente
		if("main".equals(currMethIme) && brojParametara>0) {
			report_error("Funkcija main ne sme da ima argumente", methodDecl);
		}
		//otkomentarisi kad dodas proveru za return

		//provera da li funkcija vraca nesto ako je tip razlicit od void
		//if(!returnStmt && currMethType.getType()!=Tab.noType) {
			//report_error("Funkcijiji: "+currMethIme+" fali return", methodDecl);
		//}
		
		currMethType.setLevel(brojParametara);
		brojParametara=0;
		Tab.chainLocalSymbols(currMethType);
		Tab.closeScope();
		
		currMethIme=null;
		currMethType=null;
		nadjacanObj=null;
		returnStmt=null;
		
		
	}
	//deklaracija Metoda
	
	
	
	
	
	/************************Statements***************/
	//returnStmt
	/**
	 * 
	 *Matched ::= ....(StmtReturn) RETURN AdditionalExpr SEMICOLON
	 * AdditionalExpr ::= (AddExpr) Expr
					|
				   (NoAddExpr) \/*epsilon*\/
				    ;
	 */
	public void visit(AddExpr ret) {
		if(currMethType==null || currMethType==Tab.noObj) {
			report_error("Return nije u metodi ili funkciji, vec izvan njih", ret);
			ret.struct=Tab.noType;
			return;
		}
		
		returnStmt=true;
		
		//greska ako je void povratna vrednost a postoji return
		if(currMethType.getType()==Tab.noType) {
			report_error("Return, koji vraca neku vrednost, u void funkciji ili metodi", ret);
			ret.struct=Tab.noType;
			return;
		}
		
		/****DOPUNI KASNIJE**/
		//provera da li return vraca
		/**if(currMethType.getType()!=ret.getExpr().struct) {
			report_error("Pogresan tip se vraca, funkcija ima drugaciju povratnu vrednost", ret);
			ret.struct=Tab.noType;
			return;
		}*/
		
		/**ret.struct=ret.getExpr().struct;**/
		report_info("Naisao na RETURN",ret);
		return;
	}
	
	public void visit(NoAddExpr noret) {
		if(currMethType==null || currMethType==Tab.noObj) {
			report_error("Return nije u metodi ili funkciji, vec izvan njih", noret);
			noret.struct=Tab.noType;
			return;
		}
		
		returnStmt=false;
		noret.struct=Tab.noType;
		
		if(currMethType.getType()!=Tab.noType) {
			//povratna vrednost ne postoji, a fukcije/metode nije void
			report_error("Prazan return, za non-void tip", noret);
			noret.struct=Tab.noType;
			return;
		}
		report_info("Prazna return naredba", noret);
		return;
	}
	
	/******************TERM******************/
	
	/**
	 * 
	 * Term ::= (Term) Factor OptionalTermMulop;

		OptionalTermMulop ::= (OptTermMul) OptionalTermMulop Mulop Factor
							  |
							  (NoOptTermMul) \/*epsilon*\/
							  ;
	 */
	
	
	public void visit(NoOptTermMul noTerm) {
		noTerm.struct=Tab.intType;
	}
	
	public void visit(OptTermMul optTerm) {
		Struct optTermMulOp=optTerm.getOptionalTermMulop().struct;
		Struct factor=optTerm.getFactor().struct;
		
		if(optTermMulOp!=factor || factor!=Tab.intType) {
			report_error("GRESKA:Oba operanda izraza moraju biti tipa int", optTerm);
			optTerm.struct=Tab.noType;//suptilan nacin za reci null
		}else {
			optTerm.struct=Tab.intType;
		}
	}
	
	public void visit(Term term) {
		Struct factor=term.getFactor().struct;
		Struct optTerMulOp=term.getOptionalTermMulop().struct;
		if(factor!=optTerMulOp || factor!=Tab.intType) {
			report_error("GRESKA:Oba operanda izraza moraju biti tipa int", term);
			term.struct=Tab.noType;
		}else {
			term.struct=Tab.intType;
		}
	}
	
	/***********************EXPR**************************/
	
	/**
	 * Expr ::= (Expr) AdditionalMinus Term OptionalAddopTerm;

		AdditionalMinus ::= (AdditMinus) MINUS
							|
							(NoAdditMinus) \/*epsilon*\/
							;
		OptionalAddopTerm ::= (OptAddTerm) OptionalAddopTerm Addop Term
							  |
							  (NoOptAddTerm) \/*epsilon*\/
							  ;

	 */
	
	boolean negativno=false,pozitivno=false;
	
	public void visit(OptAddTerm optAddTerm) {
		Struct addTerm=optAddTerm.getOptionalAddopTerm().struct;
		Struct term=optAddTerm.getTerm().struct;
		
		if(addTerm!=term || term!=Tab.intType) {
			report_error("GRESKA:Oba operanda izraza moraju biti tipa int", optAddTerm);
			optAddTerm.struct=Tab.noType;
		}else {
			optAddTerm.struct=Tab.intType;
		}
	}
	
	public void visit(NoOptAddTerm noOptAddTerm) {
		noOptAddTerm.struct=Tab.intType;
	}
	
	public void visit(AdditMinus minus) {
		negativno=true;
	}
	public void visit(Expr expr) {
		Struct term=expr.getTerm().struct;
		Struct optAddopTerm=expr.getOptionalAddopTerm().struct;
		
		if(term!=optAddopTerm || term!=Tab.intType) {
			report_error("GRESKA:Oba operanda izraza moraju biti tipa int", expr);
			expr.struct=Tab.noType;
		}else {
			expr.struct=Tab.intType;
		}
	}
	
	/****************ASSIGNOP| MULOP | RELOP | ADDOP ************************/
	/**
	 * Assignop ::= (Assignop) EQUALS;	
	 * Mulop ::= (MulopMul) MUL //*
		   |
		   (MulopDiv) DIV// /
		   |
		   (MulopPercent) PERCENT // %
		   ;
		   
		Relop ::= (RelEqEq) EQUALS_EQUALS // ==
		  |
		  (RelNotEq) NOT_EQUALS //!=
		  |
		  (RelGrt) GT // >
		  |
		  (RelGrtEq) GTE // >=
		  |
		  (RelLt) LT // <
		  |
		  (RelLtEq) LTE  // <=
		  ;
		 Addop ::= (AddOpPlus) PLUS // +
		  |
		  (AddOpMinus) MINUS // -
		  ;
	 * @return
	 */
	public String currOperator=null;
	
	//Asignop
	public void visit(Assignop a) {
		currOperator="=";
	}
	
	//Mulop
	public void visit(MulopMul m) {
		currOperator="*";
	}
	
	public void visit(MulopDiv d) {
		currOperator="/";
	}
	
	public void visit(MulopPercent p) {
		currOperator="%";
	}
	
	//Addop
	public void visit(AddOpPlus a) {
		currOperator="+";
	}
	
	public void visit(AddOpMinus m) {
		currOperator="-";
	}
	
	//Relop
	public void visit(RelEqEq eq) {
		currOperator="==";
	}
	public void visit(RelNotEq neq) {
		currOperator="!=";
	}
	public void visit(RelGrt g) {
		currOperator=">";
	}
	public void visit(RelGrtEq gr) {
		currOperator=">=";
	}
	public void visit(RelLt l) {
		currOperator="<";
	}
	public void visit(RelLtEq lt) {
		currOperator="<=";
	}
	
	/*********************FACTOR*******************/
	
	/**
	 *  FactorDesignator ::= (FactorDesignator) Designator;
		Factor ::= (FactorDesign) FactorDesignator AdditionalParentheses
					|
					(FactorNum) NUMCONST
					|
					(FactorChar) CHARCONST
					|
					(FactorBool) BOOLCONST
					|
					(FactorNew) NEW Type OrExprActPars
					|
					(FactorExpr) LPAREN Expr RPAREN
					;
			
		AdditionalParentheses ::= (AddParen) LPAREN AdditionalActParOp RPAREN
							|
							(NoAddParen) \/*epsilon*\/
							;
		AdditionalActParOp ::= (AddActPar2) ActPars
					   |
					   (NoAddActPar2) \/*epsilon*\/
					   ;
	    OrExprActPars ::= (OrExprop) LSQUARE Expr RSQUARE
				   |
				   (OrActPar) LPAREN AdditionalActPars RPAREN
				   ;
	 * @return
	 */
	//stakMetoda ce da sadrzi objekte u stablu koji su metode 
	Stack<Obj> stekMetoda=new Stack<>();
	//a stek argumenata ce da sadrzi argumente koji se koriste pri pozivu tih metoda
	//moglo je sve i lokalno da se cuva posto nece se pozvati naredna metoda dok se ne zavrsi
	//prethodna, ali je ovako bolje zbog prosirivosti
	Stack<List<Struct>> stekArgumenata=new Stack<>();
	
	
	public void visit(FactorDesignator fd) {
		stekMetoda.push(fd.getDesignator().obj);
		//za sada cemo samo postaviti precagu da bi kasnije umesto nje bili argumenti
		stekArgumenata.push(new ArrayList<>());
	}
	
	//factor se koristi pri racunu npr: a=b+c+f(1,2)
	
	public void visit(FactorDesign fd) {
		if(fd.getFactorDesignator().getDesignator().obj==null) return; //!!!!TEMP DOK NE IMPLEMENTIRAM DESIGNATOR!!!!
		Integer type=fd.getFactorDesignator().getDesignator().obj.getKind();
		
		if(type!=Obj.Meth) {
			report_error("GRESKA:Zove se metoda koja nije deklarisana(designator je ne prepoznaje)",fd);
			fd.struct=Tab.noType;//elegantan nacin a reci null
		}else {
			report_info("Prepoznata metoda klase ili funkcija", fd);
			//vracamo povratnu vrednost funkcije da bi se na visi nivoima dobro sabiraju vrednosti
			fd.struct=fd.getFactorDesignator().getDesignator().obj.getType();
		}
	}
	
	public void visit(FactorNew fn) {
		OrExprActPars orActPars=fn.getOrExprActPars();
		if(orActPars.getClass()==OrExprop.class) {
			if(((OrExprop)fn.getOrExprActPars()).getExpr().struct!=Tab.intType) {
				report_error("GRESKA:Operator new mora imati int tip za generisanje niza npr. new int[8]", orActPars);
				fn.struct=Tab.noType;
			}else {
				report_info("Kreiran je niz objekata tipa:"+fn.getType(), orActPars);
				fn.struct=new Struct(Struct.Array,fn.getType().struct);
			}
		}else if(orActPars.getClass()==OrActPar.class) {
			Integer klasa= fn.getType().struct.getKind();
			if(klasa!=Struct.Class) {
				report_error("GRESKA:Operatorom new pokusavate da napravite klasu koja nije deklarisana",fn);
				fn.struct=Tab.noType;
			}else {
				report_info("Kreirana je klasa operatorom new: "+fn.getType(), orActPars);
				fn.struct=fn.getType().struct;
				//!!!!!!!mozda jos nesto za trenutni konstruktor treba dodati ovde!!!!!!!!!!!!!!!!
			}
		}else {
			report_error("Desila se neka greska, new prima operator koji nije ni ActPars, a ni Expr,cudno(vrv greska neka)",fn);
		}
	}
	
	/***************************** DESIGNATOR *************************/
	/**
	 * Designator ::= (DesignatorM) DesignatorMatched
						|
						(DesignatorU) DesignatorUnmatched
					    ;
		DesPom ::= (DesPom) IDENT;
		DesignatorMatched ::= (DesMatch) DesPom OptionalDesignatorOpp;
		DesignatorUnmatched ::= (DesUnmatch) IDENT COLON COLON DesignatorMatched;
		
		OptionalDesignatorOpp ::= (OptDesignOpp) OptionalDesignatorOpp OrIdentExpr
								  |
								  (NoOptDesignOpp) \/*epsilon*\/
								  ;
		OrIdentExpr ::= (OrIdent) DOT IDENT:iden
						|
						(OrExpr) LSQUARE Expr RSQUARE
						;	
						a
						/ \
						a
						\
						b
	 * 
	 */
	//napomena Designator.a , Designator mora da bude naziv klase
	Stack<Obj> designator=new Stack<Obj>();
	boolean jedinstven=true;
	
	public void visit(DesPom dp) {
		String name=dp.getName();
		Obj obj=Tab.find(name);
		
		if(obj!=Tab.noObj) {
			dp.obj=obj;
		    report_info("Promenljivoj koja je po tipu: " +((dp.obj.getKind()==Obj.Con)?"konstanta":dp.obj.getKind()==Obj.Var?"promenjljiva":"nedefinisana"+" i njoj pristupamo."), dp);
		    return;
		}else {
			dp.obj=Tab.noObj;
			report_error("GRESKA: Promenljiva sa nazivom "+name+" ne postoji", dp);
			return;
		}
	}
	
	
	public void Designator(DesignatorM d) {
		d.obj=d.getDesignatorMatched().obj;
	}
	public void visit(DesMatch dm) {
		if(jedinstven!=true) {
			dm.obj=dm.getOptionalDesignatorOpp().obj;
		}else {
			dm.obj=dm.getDesPom().obj;
		}
		jedinstven=true;
		if(!designator.empty()) designator.pop();
	}
	
	public void visit(OptDesignOpp op) {
		/**
		if(op.getOrIdentExpr().getClass()==OrIdent.class) {
			System.out.println("-------PROBA----------: "+((OrIdent)op.getOrIdentExpr()).getIden());
		}else {
			System.out.println("-------PROBA----------: ");
		}
		*/
		
		//pristup elementu klase
		if(op.getOrIdentExpr().getClass()==OrIdent.class) {//kao instanceof
			jedinstven=false;
			if(designator.empty()) {
				op.obj=Tab.noObj;
				return;
			}
			Obj currDesignator=designator.pop();
			if(currDesignator==Tab.noObj) {
				op.obj=Tab.noObj;
				return;
			}
			
			if(currDesignator.getType().getKind()==Struct.Class) {
				report_error("GRESKA:Pristupa se polju elementa koji nije klasa", op);
				op.obj=Tab.noObj;//suptilan nacin a reci null
				return;
			}
			
			//da bi se sprecila beskonacna rekurzija ako je tip elementa klase sama ista kao i sama klasa
			//znaci ako pristupamo polju dok smo jos u klasi
			//npr. class M{M m; int a; void metod(){m.a=5;}}
			
			if(currDesignator.getType().getElemType()==potklasaTip) {
				//pronalazimo polje a,za objekat m kome pristupamo iz slikovitog primera
				Obj obj=Tab.currentScope.getOuter().findSymbol(((OrIdent)op.getOrIdentExpr()).getIden());
				
				if(obj==null) {
					report_error("Klasa: "+potklasaIme+" nema polje "+((OrIdent)op.getOrIdentExpr()).getIden(),op);
					op.obj=Tab.noObj;
					return;
				}else {
					report_info("Pristupa se polju: "+((OrIdent)op.getOrIdentExpr()).getIden()+" klase: "+potklasaIme,op);
					designator.add(obj);
					op.obj=obj;
					return;
				}
			}
			
			//pristup polju klase iz neke fruge klase ili globalne metode
			// npr. class M{M m; int a;} void pri(){m.a=5;}
			
			//posto je definicija klase ovde gotova, imamo formiran struct cvor koji ukazuje na polja i metode klase
			//zato dohvatamo sve objekte klase
			//i onda u jednoj for petlji prolazimo kroz sve elemente da vidimo da li postoji polje klase kome se pristupa
			
			ArrayList<Obj> listaPotencijalnihPolja=new ArrayList<>(currDesignator.getType().getMembers());
			
			for(Obj obj:listaPotencijalnihPolja) {
				if(((OrIdent)op.getOrIdentExpr()).getIden().equals(obj.getName())) {
					report_info("Pristupa se polju ili metodu klase izvan klase", op);
					designator.push(obj);
					op.obj=obj;
					return;
				}
			}
			
			report_error("Ne postoji polje ili metoda klase kojoj se pristupa", op);
			return;
			
		}
		//pristup elementu niza klase
		
		if(op.getOrIdentExpr().getClass()==OrExpr.class) {
			Expr expr=((OrExpr)op.getOrIdentExpr()).getExpr();
			jedinstven=false;
			if(expr.struct!=Tab.intType) {
				//ako indeksiramo niz sa elementom koji nije int
				report_error("GRESKA: Indeksiranje niza elementom koji nije int",op);
				op.obj=Tab.noObj;
				return;
			}
			
			if(designator.empty()) {
				op.obj=Tab.noObj;
				return;
			}
			
			Obj currDesignator=designator.pop();
			
			if(currDesignator!=null) {
				if(currDesignator.getType().getKind()!=Struct.Array) {
					report_error("GRESKA: Promenjljiva kojoj se trenutno pristupa nije niz",op);
					op.obj=Tab.noObj;
					return;
				}else {
					//vracamo gore samo element niza kome se pristupa odnosno njegov tip
					op.obj=new Obj(Obj.Elem,currDesignator.getName(),currDesignator.getType().getElemType());
					designator.add(op.obj);
					return;	
				}
			}
			
		}
		
	}
	
	
	
	public void visit(FactorExpr fe) {
		fe.struct=fe.getExpr().struct;
	}
	
	public void visit(FactorNum fn) {
		fn.struct=Tab.intType;
	}
	
	public void visit(FactorBool bt) {
		bt.struct=booleanType;
	}
	
	public void visit(FactorChar fc) {
		fc.struct=Tab.charType;
	}
	
	/***********************ACT PARS-stvarni argumenti pri pozivu funkcije***********/
	/**
	 * PomExprActPars ::= (PomExprActPars) Expr;
	 * ActPars ::= (ActPars) PomExprActPars OptionalComaExpr;

		OptionalComaExpr ::= (OptCommaExpr) OptionalComaExpr COMMA PomExprActPars
							  |
							  (NoOptCommaExpr) \/*epsilon*\/
							  ;
							  
		AdditionalActPars ::= (AddActPar) ActPars
							  |
							  (NoAddActPar) \/*epsilon*\/
							  ;
	 * 
	 * 
	 */
	
	//provera za klase koje su izvedene iz neke klase u samoj implementaciji nije potpuna
	//ne proverava se da li je klasa koja se dodeljuje izvedena klasa iz elementa kome se dodeljuje
	//ako je to slucaj onda je to ok
	//npr. class A{..} class B extends A{...} A a; B b; ->a=b je ok
	/**
	 * 
	 * @param s1-vrednost koja se dodeljuje
	 * @param s2-vrednost kojoj se dodeljuje
	 * @return
	 */
	public boolean AssignedToImproved(Struct s1,Struct s2) {
		//da li moze s1=s2
		if(!s1.assignableTo(s2)) {
			if(s1.getKind()==s2.getKind() && s1.getKind()==Struct.Class) {
				Struct pom=s1;
				while(pom!=null) {
					//idemo po lancu pokazivaca u strukturi
					if(pom.equals(s2)) {
						return true;
					}
					pom=pom.getElemType();
				}
			}else {
				return false;
			}
		}
		return true;
	}
	//ovde se proverava da li je broj i tipovi argumnta pri pozivu metoda/funkcija ok
	//koristimo ovo sto je definisano pre factor da bi bilo vidljivo:
	//stakMetoda ce da sadrzi objekte u stablu koji su metode 
		//Stack<Obj> stekMetoda=new Stack<>();
		//a stek argumenata ce da sadrzi argumente koji se koriste pri pozivu tih metoda
		//moglo je sve i lokalno da se cuva posto nece se pozvati naredna metoda dok se ne zavrsi
		//prethodna, ali je ovako bolje zbog prosirivosti
		//Stack<List<Struct>> stekArgumenata=new Stack<>();
	
	
	//Pojasnjenje zasto je uvedeno PomExprActPars:
	//Da to nije uvedeno onda ne bi mogli da dodajemo Expr u listu argumenata
	//jer expr moze da se koristi i za nesto drugo a ne samo za argumente funkcije
	//tako da kad ni direktnoo u Expr dodali dodavanje u stekArgumenata, onda bi
	//mozda dodali i argumente koji nisu argumenti metode nego na primer broj u neww int[expr]...
	public void visit(PomExprActPars pom) {
		//Pojasnjenje:
		//U stekArgumenata se stavljaju argumenti metoda, posto je PomExprActPars pozivan uvek
		//pre ActPars za sve argumente oni ce se svi dodati u stekArgumenata i onda
		//u ActPars proveravamo da li su broj i tipovi argumenata dobri u ActPars
		List<Struct> lista=stekArgumenata.pop();
		lista.add(pom.getExpr().struct);
		stekArgumenata.push(lista);
	}
	
	public void visit(ActPars ap) {
		//funkcija koja je pozvana
		Obj funkcija=stekMetoda.pop();
		//argumneti funkcije
		List<Struct> argument=stekArgumenata.pop();
		
		if(funkcija.getKind()==Obj.Meth) {
			//broj argumenata je jednak stvarnom broju argumenata za globalne i staticke funkcije
			//ali je broj argumenata metoda jednak stvarniBroj+1 zbog this
			//!!!!!!!!!!!!!!!!!-GORE TREBA DODATI da kad se repozna globalna funkcija da se dodaje u global listu
			//da bi mogao ovde da proverim da li je globalna i dodam +1
			if(funkcija.getLevel()!=argument.size()+(0)) {
				report_error("Broj argumenata u pozivu funkcije, ne odgovara stvarnom broju argumenata funkcije", ap);
			}else {
				//provera da li se tipovi argumenta poklapaju
				int i=0;
				for(Obj funArg:funkcija.getLocalSymbols()) {
					if(!funArg.getName().equals("this")) {
						//da li argument funkcije u pozivu moze da se dodeli stvarno argumentu
						if(!AssignedToImproved(argument.get(i), funArg.getType())) {
							report_error("Stvarni i formalni "+i+"-ci parametar se ne poklapaju",ap);
						}
						i++;
					}
					if(i==funkcija.getLevel()) {
						break;
					}
				}
			}
		}
	}
	/**
	//ako funkcija nema argumente uopste
	public void visit(NoAddActPar nap) {
		//trenutno ovako dok ne implementiram sve ---------------------------
		if(stekArgumenata.empty() || stekMetoda.empty()) return;
		//funkcija koja je pozvana
		Obj funkcija=stekMetoda.pop();
		//argumneti funkcije
		List<Struct> argument=stekArgumenata.pop();
		if(funkcija.getKind()==Obj.Meth) {
			//broj argumenata je jednak stvarnom broju argumenata za globalne i staticke funkcije
			//ali je broj argumenata metoda jednak stvarniBroj+1 zbog this
			//!!!!!!!!!!!!!!!!!-GORE TREBA DODATI da kad se repozna globalna funkcija da se dodaje u global listu
			//da bi mogao ovde da proverim da li je globalna i dodam +1
			if(funkcija.getLevel()!=argument.size()+(0)) {
				report_error("Broj argumenata u pozivu funkcije, ne odgovara stvarnom broju argumenata funkcije", nap);
			}else {
				//provera da li se tipovi argumenta poklapaju
				int i=0;
				for(Obj funArg:funkcija.getLocalSymbols()) {
					if(!funArg.getName().equals("this")) {
						//da li argument funkcije u pozivu moze da se dodeli stvarno argumentu
						if(!AssignedToImproved(argument.get(i), funArg.getType())) {
							report_error("Stvarni i formalni "+i+"-ci parametar se ne poklapaju",nap);
						}
						i++;
					}
					if(i==funkcija.getLevel()) {
						break;
					}
				}
			}
		}
		
	}
	*/
	/**
	//dva puta sam pisao AdditionalActPars ?????????? pa se zbog toga duplira i kod
	//ako funkcija nema argumente uopste
	public void visit(NoAddActPar2 nap) {
			//funkcija koja je pozvana
			Obj funkcija=stekMetoda.pop();
			//argumneti funkcije
			List<Struct> argument=stekArgumenata.pop();
			if(funkcija.getKind()==Obj.Meth) {
				//broj argumenata je jednak stvarnom broju argumenata za globalne i staticke funkcije
				//ali je broj argumenata metoda jednak stvarniBroj+1 zbog this
				//!!!!!!!!!!!!!!!!!-GORE TREBA DODATI da kad se repozna globalna funkcija da se dodaje u global listu
				//da bi mogao ovde da proverim da li je globalna i dodam +1
				if(funkcija.getLevel()!=argument.size()+(0)) {
					report_error("Broj argumenata u pozivu funkcije, ne odgovara stvarnom broju argumenata funkcije", nap);
				}else {
					//provera da li se tipovi argumenta poklapaju
					int i=0;
					for(Obj funArg:funkcija.getLocalSymbols()) {
						if(!funArg.getName().equals("this")) {
							//da li argument funkcije u pozivu moze da se dodeli stvarno argumentu
							if(!AssignedToImproved(argument.get(i), funArg.getType())) {
								report_error("Stvarni i formalni "+i+"-ci parametar se ne poklapaju",nap);
							}
							i++;
						}
						if(i==funkcija.getLevel()) {
							break;
						}
					}
				}
			}
			
	}
	*/
	/****************** COND FACT  ***************************/
	
	/**
	 * 
	 * CondFact ::= (CondFact) Expr AdditionalRelopExpr;

		AdditionalRelopExpr ::= (AddRelopExpr) Relop Expr
								|
								(NoAddRelopExpr) \/*epsilon*\/
								;
		AdditionalCondFact ::= (AddCondFact) CondFact
								|
								(NoAddCondFact) \/*epsilon*\/
								;
	 * 
	 * @return
	 */
	
	boolean hasSecondExpr=false;
	Expr secondExpr=null;
	
	public void visit(AddRelopExpr are) {
		hasSecondExpr=true; secondExpr=are.getExpr();
	}
	
	public void visit(CondFact cf) {
		if(cf.getExpr().struct!=booleanType && !hasSecondExpr) {
			report_error("Tip expr-esa mora biti boolean", cf);
			cf.struct=Tab.noType;
			return;
		}
		if(!hasSecondExpr) {
			cf.struct=cf.getExpr().struct;
			return;
		}
		//kompatibilnost uslova
		if(!secondExpr.struct.compatibleWith(cf.struct)){
			cf.struct=Tab.noType;
			report_error("Izrazi nisu komatibilni za dodelu", cf);
			return;
		}
		//jos je ostalo implementirati proveru za nizove
		//Uz promenljive tipa klase ili niza, od relacionih operatora, mogu se koristiti samo != i ==
		
		Integer exprKind=cf.getExpr().struct.getKind();
		Integer secondExprKind=secondExpr.struct.getKind();
		
		if(exprKind==secondExprKind && exprKind==Struct.Array && !currOperator.equals("!=") && !currOperator.equals("==")) {
			report_error("GRESKA:Nizovi mogu da se porede samo na != i ==",cf);
			cf.struct=Tab.noType;
			return;
		}else if(exprKind==secondExprKind && exprKind==Struct.Array && !currOperator.equals("!=") && !currOperator.equals("==")) {
			report_error("GRESKA:Klase se porede samo na == i !=", cf);
			cf.struct=Tab.noType;
			return;
		}
		
		hasSecondExpr=false;
	}
		
	/*****************COND TERM************************************/
	/**
	 * CondTerm ::= (CondTerm) CondFact OptionalCondFact;

	   OptionalCondFact ::= (OptCondFact) OptionalCondFact AND CondFact
					  |
					 (NoOptCondFact) \/*epsilon*\/
					 ;
	 */
	
	public void visit(CondTerm ct) {
		if(!(ct.getCondFact().struct==booleanType && ct.getOptionalCondFact().struct==booleanType)) {
			report_error("GRESKA: Tipovi nisu kompatibilni u cond term-u", ct);
			ct.struct=Tab.noType;
			return;
		}
		ct.struct=booleanType;
		return;
	}
	
	public void visit(OptCondFact oct) {
		//mada smo vec to proverili na dubljim nivoima
		if(!(oct.getCondFact().struct==booleanType && oct.getOptionalCondFact().struct==booleanType)) {
			report_error("GRESKA: Tipovi nisu kompatibilni u cond term-u", oct);
			oct.struct=Tab.noType;
			return;
		}
		oct.struct=booleanType;
		return;
	}
	
	public void visit(NoOptCondFact nct) {
		nct.struct=booleanType;
	}
	/****************CONDITION*************************************/
	/**
	 * Condition ::= (Condition) CondTerm OptionalCondTerm;

	   OptionalCondTerm ::= (OptCondTerm) OptionalCondTerm OR CondTerm
					  |
					  (NoOptCondTerm) \/*epsilon*\/
					  ;
	 * @return
	 */
	
	public void visit(NoOptCondTerm noct) {
		noct.struct=booleanType;
	}
	
	public void visit(OptCondTerm oct) {
		if(!(oct.getOptionalCondTerm().struct==booleanType && oct.getCondTerm().struct==booleanType)) {
			report_error("GRESKA: Tipovi nisu kompatibilni u cond term-u", oct);
			oct.struct=Tab.noType;
			return;
		}
		oct.struct=booleanType;
		return;
	}
	
	public void visit(Condition c) {
		if(!(c.getOptionalCondTerm().struct==booleanType && c.getCondTerm().struct==booleanType)) {
			report_error("GRESKA: Tipovi nisu kompatibilni u cond term-u", c);
			c.struct=Tab.noType;
			return;
		}
		c.struct=booleanType;
		return;
	}
	
	/****************** DESIGNATOR STATEMENT *********************/
	/**
	 * DesignatorStatement ::= (DesStmtE) Designator OrDesStmt
						|
						(DesStmtH) LSQUARE OptionalDesignComma MUL Designator RSQUARE EQUALS Designator
						;

		OrDesStmt ::= (OrAssignExpr) Assignop Expr
					  |
					  (OrActPars) LPAREN AdditionalActPars RPAREN
					  |
					  (OrIncrement) INCREMENT
					  |
					  (OrDecrement) DECREMENT
					  ;
					  
		
							
		OptionalDesignComma ::= (OptDesCom) OptionalDesignComma AdditionalDesign COMMA
								|
								(NooOptDesCom) \/*epsilon*\/
								;
		AdditionalDesign ::= (AdditionalDes) Designator
							 |
							 (NoAdditionalDes) \/*epsilon*\/
							 ;
	 * @return
	 */
	//ovde visie nista necemo slati na gore posto se u ovom podstablu sve isproveravalo
	//tako da na visim instancama nema potrebe dalje proveravati ono sto je vec provereno
	
	//ova funkcija ce proveravati uslove koji se odnose na DesStmE--napomena: to je skracenica od easy
	public void visit(DesStmtE des) {
		if(des.getOrDesStmt().getClass()==OrAssignExpr.class) {//dodela vrednosti a=1
			Expr expr=((OrAssignExpr)des.getOrDesStmt()).getExpr();
			Integer kind=des.getDesignator().obj.getType().getKind();
			//ako promenljiva kojoj se vrsi dodela, nije ni element niza, ni polje klase, ni globalna promenjljiva, onda je to greska
			if(kind!=Obj.Elem && kind!=Obj.Fld && kind!=Obj.Var) {
				report_error("GRESKA:Dodela se vrsi izrazu koji nije ni globalna promenljiva, ni promenjljiva klase, ni element niza", expr);
				return;
			}
			
			//druga greska je ako se vrsi dodela nekompatibilnim tipovima
			//za tu priliku sam napisao posebnu metodu koja je redefinicija 
			//metode AssignTo, a koja jos proverava da li moze da se vrsi dodela
			//podtipa nadtipu, ako su tipovi klase
			if(!AssignedToImproved(expr.struct,des.getDesignator().obj.getType())) {
				report_error("GRESKA: Tip za dodelu je nekompatibilan", expr);
				return;
			}
		}else if(des.getOrDesStmt().getClass()==OrIncrement.class) {//inkrementiranje i++
			if(des.getDesignator().obj.getType()!=Tab.intType) {
				report_error("GRESKA:Pokusavate inc za promenjljivu koja nije int",des);
				return;
			}
			if(
					des.getDesignator().obj.getType().getKind()!=Obj.Var &&
					des.getDesignator().obj.getType().getKind()!=Obj.Fld &&
					des.getDesignator().obj.getType().getKind()!=Obj.Elem
					) {
				report_error("GRESKA:Pokusavate inc promenjljive koja nije ni lokalna ni globalna, ni klasna", des);
				return;
			}
		}else if(des.getOrDesStmt().getClass()==OrDecrement.class) {//dekrementiranje i--
			if(des.getDesignator().obj.getType()!=Tab.intType) {
				report_error("GRESKA:Pokusavate dec za promenjljivu koja nije int",des);
				return;
			}
			if(
					des.getDesignator().obj.getType().getKind()!=Obj.Var &&
					des.getDesignator().obj.getType().getKind()!=Obj.Fld &&
					des.getDesignator().obj.getType().getKind()!=Obj.Elem
					) {
				report_error("GRESKA:Pokusavate dec promenjljive koja nije ni lokalna ni globalna, ni klasna", des);
				return;
			}
		}else if(des.getOrDesStmt().getClass()==OrActPars.class) {//poziv funkcije f(1,2,3)
			//!!!!!!!!!!!!!!!!!!!!!!!!!1Moguca greska jer nije koriscen FactorDesignator umesto Designatora u cupu-u proveri kasnije
			if(des.getDesignator().obj.getKind()!=Obj.Meth) {
				report_error("GRESKA: Vrsite poziv necega sto nije ni funkcija ni metoda", des);
				return;
			}
		}
	}
	
	//[a,b,*c]=[1,2,3,4]=>a=1;b=2;c=[3,4]
	List<Obj> designatorsList=new ArrayList<>();
	
	public void visit(AdditionalDes des) {
		if(
				des.getDesignator().obj.getType().getKind()!=Obj.Var &&
				des.getDesignator().obj.getType().getKind()!=Obj.Fld &&
				des.getDesignator().obj.getType().getKind()!=Obj.Elem
				) {
			report_error("GRESKA:Pokusavate dodelu promenjljivoj koja nije ni lokalna ni globalna, ni klasna", des);
			return;
		}else {
			designatorsList.add(des.getDesignator().obj);
		}
	}
	public void visit(DesStmtH des) {//skaraceno od hard :)
		//ovde treba uraditi nekoliko provera
		
		//provera da li je poslednji element liste niz [a,b,*c], c mora biti niz
		Struct array=des.getDesignator().obj.getType();
		if(array.getKind()==Struct.Array) {
		
			report_error("GRESKA:Poslednji element u listi nije niz", des);
			return;
		}
		
		//provera da li je poslednji element niza kompatibilan sa vrednosti koja se dodeljuje
		if(!AssignedToImproved(des.getDesignator().obj.getType().getElemType(), des.getDesignator1().obj.getType().getElemType())){
			report_error("GRESKA:Tip elementa niza poslednjeg elementa se ne poklapa sa tipom elementa vrednosti koja se dodeljuje", des);
			return;
		}
		
		//priovera da li ostatak elemenata niza od 0 do n-2 (ako je duzina niza n)-moze im se dodeli vrednost sa desne strane
		
		for(Obj obj:designatorsList) {
			if(!AssignedToImproved(des.getDesignator1().obj.getType().getElemType(), obj.getType())) {
				report_error("GRESKA:Neki element liste nema kompatibilan tip sa elementom sa desne strane znaka jednako", des);
				return;
			}
		}
		designatorsList.clear();
	}
	public boolean passed(){
    	return !errorDetected;
    }
}
